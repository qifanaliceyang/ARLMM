# -*- coding: utf-8 -*-
"""Autoreressive_correlation_matrix_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jNXX4n7o91jCq27pd-NTYRoWMoahsYZa
"""

def jennrich_test(corr_matrix_1, corr_matrix_2, n1, n2):
    """
    Perform Jennrich's Test to compare two correlation matrices.

    Parameters:
    - corr_matrix_1: Correlation matrix from group 1 (numpy array)
    - corr_matrix_2: Correlation matrix from group 2 (numpy array)
    - n1: Sample size of group 1
    - n2: Sample size of group 2

    Returns:
    - chi_squared_stat: The test statistic
    - p_value: The p-value of the test
    """
    p = corr_matrix_1.shape[0]  # Number of variables
    df = p * (p - 1) / 2  # Degrees of freedom

    # Fisher Z-transformation of the correlation matrices
    z_corr1 = np.arctanh(corr_matrix_1 - np.eye(p))
    z_corr2 = np.arctanh(corr_matrix_2 - np.eye(p))

    # Difference matrix
    delta = z_corr1 - z_corr2

    # Variance of the differences
    var_diff = 1 / (n1 - 3) + 1 / (n2 - 3)

    # Compute the test statistic
    chi_squared_stat = np.nansum((delta ** 2)) * var_diff

    # Compute the p-value
    p_value = chi2.sf(chi_squared_stat, df)

    return chi_squared_stat, p_value

# Sample sizes for each diagnostic group
sample_sizes = {
    "sCN": average_timepoint_volumes.shape[0],
    "sMCI": new_average_correlation_data.shape[0],
    "cMCI": converter_average_data.shape[0],
    "sAD": sAD_average_data.shape[0]
}

# Correlation matrices for each diagnostic group
correlation_matrices = {
    "sCN": renamed_datasets["sCN"].corr().values,
    "sMCI": renamed_datasets["sMCI"].corr().values,
    "cMCI": renamed_datasets["cMCI"].corr().values,
    "sAD": renamed_datasets["sAD"].corr().values
}

# List of group names
groups = ["sCN", "sMCI", "cMCI", "sAD"]

# Perform Jennrich's Test for each pairwise combination
jennrich_results = {}

for i in range(len(groups)):
    for j in range(i + 1, len(groups)):
        group1 = groups[i]
        group2 = groups[j]
        corr_matrix_1 = correlation_matrices[group1]
        corr_matrix_2 = correlation_matrices[group2]
        n1 = sample_sizes[group1]
        n2 = sample_sizes[group2]
        chi_squared_stat, p_value = jennrich_test(corr_matrix_1, corr_matrix_2, n1, n2)
        jennrich_results[f"{group1} vs {group2}"] = (chi_squared_stat, p_value)

# Display the results
for comparison, (chi_stat, p_val) in jennrich_results.items():
    print(f"{comparison}: Chi-squared = {chi_stat:.4f}, p-value = {p_val:.4f}")

# Re-run the likelihood ratio test specifically for recalculating the chi-square and p-values for sCN and sMCI matrices

# Define the likelihood ratio test function again for clarity
def likelihood_ratio_test_ar1(correlation_matrix):
    """
    Perform a likelihood ratio test comparing the observed correlation matrix
    to an AR(1) structure.
    """
    # Step 1: Estimate lag-1 correlation as the average of the first off-diagonal elements
    n = correlation_matrix.shape[0]
    lag_1_estimated_rho = np.mean([correlation_matrix[i, i + 1] for i in range(n - 1)])

    # Step 2: Construct the expected AR(1) matrix
    expected_ar1_matrix = np.array([[lag_1_estimated_rho ** abs(i - j) for j in range(n)] for i in range(n)])

    # Step 3: Calculate log-likelihoods for both matrices
    sign_obs, logdet_obs = slogdet(correlation_matrix)
    log_likelihood_obs = -0.5 * n * logdet_obs if sign_obs > 0 else np.nan

    sign_ar1, logdet_ar1 = slogdet(expected_ar1_matrix)
    log_likelihood_ar1 = -0.5 * n * logdet_ar1 if sign_ar1 > 0 else np.nan

    # Step 4: Compute the likelihood ratio statistic
    if not np.isnan(log_likelihood_obs) and not np.isnan(log_likelihood_ar1):
        chi_squared_stat = 2 * (log_likelihood_obs - log_likelihood_ar1)
        degrees_of_freedom = (n * (n - 1)) / 2
        p_value = chi2.sf(chi_squared